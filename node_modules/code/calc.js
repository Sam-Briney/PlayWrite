var construct = require("code/construct.js");

exports.head = function(line){//line is object
	var headlen = 15;   // length of head in pixels
	var angle = Math.atan2(line.b.y-line.a.y,line.b.x-line.a.x);

	var angleB = 6;
	if(line.type === "screen" || line.type === "screen~"){
		angleB = 2;
	}

	line.head.pa.x = line.b.x-headlen*Math.cos(angle-Math.PI/angleB);
	line.head.pa.y = line.b.y-headlen*Math.sin(angle-Math.PI/angleB);

	line.head.pb.x = line.b.x-headlen*Math.cos(angle+Math.PI/angleB);
	line.head.pb.y = line.b.y-headlen*Math.sin(angle+Math.PI/angleB);

	return line;
};

exports.pass = function(line){
	var distance = (Math.pow((line.a.x - line.b.x), 2) + Math.pow((line.a.y - line.b.y), 2));
	if(distance < 0){
		distance *= -1;
	}
	distance = Math.pow(distance, 0.5);
	//13 = pixels between dots
	var num_dots = Math.ceil(distance/13);
	return num_dots;
};

exports.curve = function(line){
	line.b.y = line.curve[line.curve.length - 1].y;
	line.a.y = line.curve[line.curve.length - 2].y;

	line.b.x = line.curve[line.curve.length - 1].x;
	line.a.x = line.curve[line.curve.length - 2].x;

	return line;
};

var waypoint = function (start, end, q) {
	return {
		x: start.x + (end.x - start.x) * q,
		y: start.y + (end.y - start.y) * q
	};
}

exports.waypoint = waypoint;

exports.waypoints = function(pa, pb, px, single){

	var distance = Math.pow(Math.abs((Math.pow((pa.x - pb.x), 2) + Math.pow((pa.y - pb.y), 2))), 0.5);

	var curves = Math.floor(distance / px);

	var points = [];
	if(single){
		points.push(pa);
		curves++;
	}

	while((curves - 1) % 3 !== 0){
		curves++;
	}

	var curveInterval = 100 / curves;

	for(iii=curveInterval; iii<100; iii += curveInterval){
		var per = iii / 100;
		points.push(waypoint(pa, pb, per));
	}

	return points;

}

exports.bezier = function(points){
	var result = [];
	for(iii=1; iii<points.length; iii++){
		var headlen = 8;   // length of head in pixels
		var angle = Math.atan2(points[iii].y-points[0].y,points[iii].x-points[0].x);

		angleB = 2;

		var tempRes = {};
		if((iii + 1) % 3 === 0){
			tempRes.x = points[iii].x-headlen*Math.cos(angle-Math.PI/angleB);
			tempRes.y = points[iii].y-headlen*Math.sin(angle-Math.PI/angleB);
		}
		else if(iii % 3 === 0){
			tempRes.x = points[iii].x-headlen*Math.cos(angle+Math.PI/angleB);
			tempRes.y = points[iii].y-headlen*Math.sin(angle+Math.PI/angleB);
		}
		else{
			tempRes = {
				x: points[iii].x,
				y: points[iii].y
			}
		}
		result.push(tempRes);
	}
	return result;
}

exports.reprocess = function(line, edit, point){
	if(line.type === "arrow" || line.type === "screen" || line.type === "pass" || line.type === "dribble"){
		var temp_line2 = {
			a_done: false,
			type: line.type,
			a: {
				x: line.a.x,
				y: line.a.y
			},
			b: {
				x: line.b.x,
				y: line.b.y
			},
			head: {
				pa:{
					x:0,
					y:0
				},
				pb:{
					x:0,
					y:0
				}
			},
			num_dots: 0,
			curve:[]
			//curve on right click
		};

		temp_line2[edit] = {
			x: point.x,
			y: point.y
		}

		temp_line2 = exports.head(temp_line2);
		return new construct.Line_data(temp_line2);
	}
	else{
		return line;
	}
}


 exports.translate = function(line_arr, to_full, outside_lines){
	//height
	var h;

	if(to_full){
		h = 420;
		if(outside_lines){
			h -= 26;
		}
	}
	else{
		h = -420;
		if(outside_lines){
			h += 26;
		}
	}

	for(i=0; i<line_arr.length; i++){
		//a
		line_arr[i].a.y += h;

		//b
		if(line_arr[i].type === "arrow" || line_arr[i].type === "screen" || line_arr[i].type === "pass" || line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
			line_arr[i].b.y += h;

			//head
			line_arr[i].head.pa.y += h;
			line_arr[i].head.pb.y += h;

			line_arr[i].handle.y += h;
		}

		//curve
		if(line_arr[i].type === "arrow~" || line_arr[i].type === "screen~"){
			//head
			line_arr[i].head.pa.y += h;
			line_arr[i].head.pb.y += h;
			for(ii=0; ii<line_arr[i].curve.length; ii++){
				line_arr[i].curve[ii].y += h;
			}

			line_arr[i].handle.y += h;
		}
		else if(line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
			for(ii=0; ii<line_arr[i].points.length; ii++){
				line_arr[i].points[ii].y += h;
			}
		}
	}

	return line_arr;
};

exports.translate_text_boxes = function(text_boxes, to_full){
	var h;

	if(to_full){
		h = 420;
	}
	else{
		h = -420;
	}

	for(i=0; i<text_boxes.length; i++){
		text_boxes[i].position.y += h;
		if(text_boxes[i].position.y < 1){
			text_boxes[i].position.y = 10;
		}
	}
	return text_boxes;
}

exports.scale = function(line_arr, outside_lines, full_court){

	var handle_offset = 10;

	var trX = 37.5;
	var trY = 63;

	if(full_court === false){
		trX = 37.5;
		trY = 25.5;
	}

	var scX, scY;

	var sc = 0.85;

	if(outside_lines === true){

		scX = function(line){
			return (line * sc) + trX;
		};
		scY = function(line){
			return (line * sc) + trY;
		};

		for(i=0; i<line_arr.length; i++){
			//a
			line_arr[i].a.x = scX(line_arr[i].a.x);
			line_arr[i].a.y = scY(line_arr[i].a.y);

			//b
			if(line_arr[i].type === "arrow" || line_arr[i].type === "screen" || line_arr[i].type === "pass" || line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
				line_arr[i].b.x = scX(line_arr[i].b.x);
				line_arr[i].b.y = scY(line_arr[i].b.y);

				//head
				line_arr[i].head.pa.x  = scX(line_arr[i].head.pa.x);
				line_arr[i].head.pa.y  = scY(line_arr[i].head.pa.y);

				line_arr[i].head.pb.x  = scX(line_arr[i].head.pb.x);
				line_arr[i].head.pb.y  = scY(line_arr[i].head.pb.y);
			}

			//curve
			if(line_arr[i].type === "arrow~" || line_arr[i].type === "screen~"){
				//head
				line_arr[i].head.pa.x = scX(line_arr[i].head.pa.x);
				line_arr[i].head.pa.y = scY(line_arr[i].head.pa.y);

				line_arr[i].head.pb.x = scX(line_arr[i].head.pb.x);
				line_arr[i].head.pb.y = scY(line_arr[i].head.pb.y);

				for(ii=0; ii<line_arr[i].curve.length; ii++){
					line_arr[i].curve[ii].x = scX(line_arr[i].curve[ii].x);
					line_arr[i].curve[ii].y = scY(line_arr[i].curve[ii].y);

				}
			}
			else if(line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
				for(ii=0; ii<line_arr[i].points.length; ii++){
					line_arr[i].points[ii].x = scX(line_arr[i].points[ii].x);
					line_arr[i].points[ii].y = scY(line_arr[i].points[ii].y);

				}
			}
			if(line_arr[i].type === "arrow" || line_arr[i].type === "screen" || line_arr[i].type === "pass" || line_arr[i].type === "dribble"){

				line_arr[i].handle = {
					x: (line_arr[i].a.x + line_arr[i].b.x)/2 - handle_offset,
					y: (line_arr[i].a.y + line_arr[i].b.y)/2 - handle_offset
				}
			}
			if(line_arr[i].type === "dribble~"){

				function roundto3(n){
					if(n > 0){
						n = Math.floor(n/3.0) * 3;
					}
					else{
						n = 0;
					}

					if(n >= line_arr[i].points.length){
						n = 0;
					}

					return n;
				}

				line_arr[i].handle = {
					x: line_arr[i].points[roundto3(line_arr[i].points.length/2)].x - handle_offset,
					y: line_arr[i].points[roundto3(line_arr[i].points.length/2)].y - handle_offset
				}


			}
			if(line_arr[i].type === "arrow~" || line_arr[i].type === "screen~"){
				line_arr[i].handle = {
					x: line_arr[i].curve[Math.round(line_arr[i].curve.length/2)].x - handle_offset,
					y: line_arr[i].curve[Math.round(line_arr[i].curve.length/2)].y - handle_offset
				}
				console.log(line_arr);
			}
		}
	}
	else{
		scX = function(line){
			return (line - trX)/sc;
		};
		scY = function(line){
			return (line - trY)/sc;
		};

		for(i=0; i<line_arr.length; i++){
			//a
			line_arr[i].a.x = scX(line_arr[i].a.x);
			line_arr[i].a.y = scY(line_arr[i].a.y);

			//b
			if(line_arr[i].type === "arrow" || line_arr[i].type === "screen" || line_arr[i].type === "pass" || line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
				line_arr[i].b.x = scX(line_arr[i].b.x);
				line_arr[i].b.y = scY(line_arr[i].b.y);

				//head
				line_arr[i].head.pa.x  = scX(line_arr[i].head.pa.x);
				line_arr[i].head.pa.y  = scY(line_arr[i].head.pa.y);

				line_arr[i].head.pb.x  = scX(line_arr[i].head.pb.x);
				line_arr[i].head.pb.y  = scY(line_arr[i].head.pb.y);
			}

			//curve
			if(line_arr[i].type === "arrow~" || line_arr[i].type === "screen~"){
				//head
				line_arr[i].head.pa.x = scX(line_arr[i].head.pa.x);
				line_arr[i].head.pa.y = scY(line_arr[i].head.pa.y);

				line_arr[i].head.pb.x = scX(line_arr[i].head.pb.x);
				line_arr[i].head.pb.y = scY(line_arr[i].head.pb.y);

				for(ii=0; ii<line_arr[i].curve.length; ii++){
					line_arr[i].curve[ii].x = scX(line_arr[i].curve[ii].x);
					line_arr[i].curve[ii].y = scY(line_arr[i].curve[ii].y);

				}
			}
			else if(line_arr[i].type === "dribble~" || line_arr[i].type === "dribble"){
				for(ii=0; ii<line_arr[i].points.length; ii++){
					line_arr[i].points[ii].x = scX(line_arr[i].points[ii].x);
					line_arr[i].points[ii].y = scY(line_arr[i].points[ii].y);

				}
			}
		}

	}

	for(i=0; i<line_arr.length; i++){
		if(line_arr[i].type === "arrow" || line_arr[i].type === "screen" || line_arr[i].type === "pass" || line_arr[i].type === "dribble"){

			line_arr[i].handle = {
				x: (line_arr[i].a.x + line_arr[i].b.x)/2 - handle_offset,
				y: (line_arr[i].a.y + line_arr[i].b.y)/2 - handle_offset
			}
		}
		if(line_arr[i].type === "dribble~"){

			function roundto3(n){
				if(n > 0){
					n = Math.floor(n/3.0) * 3;
				}
				else{
					n = 0;
				}

				if(n >= line_arr[i].points.length){
					n = 0;
				}

				return n;
			}

			line_arr[i].handle = {
				x: line_arr[i].points[roundto3(line_arr[i].points.length/2)].x - handle_offset,
				y: line_arr[i].points[roundto3(line_arr[i].points.length/2)].y - handle_offset
			}

		}
		if(line_arr[i].type === "arrow~" || line_arr[i].type === "screen~"){
			line_arr[i].handle = {
				x: line_arr[i].curve[Math.round(line_arr[i].curve.length/2)].x - handle_offset,
				y: line_arr[i].curve[Math.round(line_arr[i].curve.length/2)].y - handle_offset
			}
		}
	}

	return line_arr;
};

function S4(){
	return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
}

exports.guid = function(){
	return (S4() + S4() + "-" + S4() + "-4" + S4().substr(0,3) + "-" + S4() + "-" + S4() + S4() + S4()).toLowerCase();
}

function distance(a, b){
	return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

exports.continue_frame = function(frame, $){
	var lines = [],
		arr = [],
		passes = [];

	for(i=0; i<frame.line_arr.length; i++){
		if(/^ball$|^o$|^x$|^[ball|o|x]+[1-5]$/.test(frame.line_arr[i].type) === true){
			arr.push($.extend({}, frame.line_arr[i]));
		}
		else if(frame.line_arr[i].type !== "pass"){
			lines.push(frame.line_arr[i])
		}
		else{
			passes.push(frame.line_arr[i]);
		}
	}

	var move_players = function move(){
		for(i=0; i<arr.length; i++){
			arr[i].close = [];

			for(ii=0; ii<lines.length; ii++){
				var d, b;

				if(lines[ii].type === "arrow" || lines[ii].type === "screen" || lines[ii].type === "dribble"){
					d = distance({
						x: arr[i].a.x + 12.5,
						y: arr[i].a.y + 12.5
					}, lines[ii].a);

					b = lines[ii].b;
				}
				else if(lines[ii].type === "dribble~"){
					d = distance({
						x: arr[i].a.x + 12.5,
						y: arr[i].a.y + 12.5
					}, lines[ii].points[0]);

					b = lines[ii].points[lines[ii].points.length - 1];
				}
				else{
					d = distance({
						x: arr[i].a.x + 12.5,
						y: arr[i].a.y + 12.5
					}, lines[ii].curve[0]);

					b = lines[ii].curve[lines[ii].curve.length - 1];
				}

				if(d <= 40){
					arr[i].close.push({
						d: d,
						index: ii,
						point: {
							x: b.x - 12.5,
							y: b.y - 12.5
						}
					});
				}
			}

			arr[i].close.sort(function(a, b){
				return a.d-b.d;
			});

		}

		for(i=0; i<arr.length; i++){

			for(ii=0; ii<arr[i].close.length; ii++){
				arr[i].close[ii].disputed = [];

				for(iii=0; iii<arr.length; iii++){
					for(iiii=0; iiii<arr[iii].close.length; iiii++){
						if(arr[i].close[ii].index === arr[iii].close[iiii].index && i !== iii){
							arr[i].close[ii].disputed.push(iii);
						}
					}
				}

			}
		}

		for(i=0; i<arr.length; i++){
			var point = {
				x: arr[i].a.x,
				y: arr[i].a.y
			};

			if(arr[i].close.length > 0){
				//not disputed
				if(arr[i].close[0].disputed.length === 0){
					point = {
						x: arr[i].close[0].point.x,
						y: arr[i].close[0].point.y
					}

					//log the line as used
					lines[arr[i].close[0].index].used = true;
				}
				else if(arr[i].close.length === 1){
					if(lines[arr[i].close[0].index].used !== true){
						var disputed = [];

						//eliminate disputes with other options
						for(ii=0; ii<arr[i].close[0].disputed.length; ii++){
							if(arr[arr[i].close[0].disputed[ii]].close.length === 1){
								disputed.push(arr[i].close[0].disputed[ii]);
							}
						}

						//trump due to multiple options on other players
						if(disputed.length === 0){
							point.x = arr[i].close[0].point.x,
							point.y = arr[i].close[0].point.y

							//log the line as used
							lines[arr[i].close[0].index].used = true;
						}
						else{
							//no trump because other players have only one option as well
							//use the closest player
							var closest = 1000;
							for(ii=0; ii<disputed.length; ii++){
								if(arr[disputed[ii]].close[0].d < closest){
									closest = arr[disputed[ii]].close[0].d;
								}
							}

							if(closest > arr[i].close[0].d){
								point.x = arr[i].close[0].point.x,
								point.y = arr[i].close[0].point.y

								//log the line as used
								lines[arr[i].close[0].index].used = true;
							}
						}
					}
				}
				else{
					//if this line has multiple options and disputes
					//eliminate used lines
					for(ii=0; ii<arr[i].close.length; ii++){
						if(lines[arr[i].close[ii].index].used === true){
							arr[i].close[ii].del = true;
						}
					}

					arr[i].close = arr[i].close.filter(function(value){
						if(value.del === true){
							return false;
						}
						else{
							return true;
						}
					});

					//if only one option or an undisputed first option move the loop back and continue
					if(arr[i].close.length === 1 || arr[i].close[0].disputed.length === 0){
						i--;
						continue;
					}
					else{
						//if multiple options and at least 1 dispute, check for non-disputed lines
						var set = false;
						for(ii=0; ii<arr[i].close.length; ii++){
							if(arr[i].close[ii].disputed.length === 0){
								point.x = arr[i].close[ii].point.x,
								point.y = arr[i].close[ii].point.y
								set = true;

								//log the line as used
								lines[arr[i].close[0].index].used = true;
								break;
							}
						}

						//if all lines are disputed take the closest line or nothing
						if(!set){
							arr[i].close = [arr[i].close[0]];
							i--;
							continue;
						}
					}
				}
			}

			arr[i].a = {
				x: point.x,
				y: point.y
			}
		}

		var len = lines.length;
		lines = lines.filter(function(value){
			if(value.used === true){
				return false;
			}
			else{
				return true;
			}
		});

		if(lines.length < len){
			return move();
		}
	}

	move_players();

	if(passes.length > 0){
		var pass = passes[passes.length - 1];

		var closest = 1500;
		var index = -1;

		var ball_index = -1;

		for(i=0; i<arr.length; i++){
			if(/^ball$|^o$|^[ball|o]+[1-5]$/.test(arr[i].type) === true){
				var d = distance({
					x: arr[i].a.x + 12.5,
					y: arr[i].a.y + 12.5
				}, pass.b);

				if(d < closest){
					closest = d;
					index = i;
				}
			}

			if(/^ball$|^[ball]+[1-5]$/.test(arr[i].type) === true){
				ball_index = i;
			}
		}

		if(index > -1 && ball_index > -1){
			arr[ball_index].type = arr[ball_index].type.replace("ball", "o");
			arr[index].type = arr[index].type.replace("o", "ball");
		}
	}

	for(i=0; i<arr.length; i++){
		//delete arr[i].close;
	}
	for(i=0; i<lines.length; i++){
		//delete lines[i].used;
	}

	return arr;
}
